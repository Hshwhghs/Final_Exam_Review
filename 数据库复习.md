## 第三章 SQL基础

### 3.2 SQL数据定义

#### 3.2.1 基本类型

- char(n)
- varchar(n)
- int
- smallint
- numeric(p,d):如numeric(5,2)可以存444.32,但是不能存44.332
- real,double precision
- float(n):精度至少为n位的浮点数

#### 3.2.2 基本模式定义

$$
create\ table \ r\\
(A_1,D_1\\
A_2,D_2\\
....\\
A_n,D_n\\
<完整性约束_1>\\
....\\
<完整性约束_k>);
$$



完整性约束：

- $primary\ key(A_1,A_2..A_k)$
- $foriegn\ key(A_1,A_2,..A_k)\ \ references\ s$
- $not\  null$

对表的操作

- drop table :删除表
- delete from table :删除所有元组，但是不删除表
- alter table r add A D:新增属性，以及它的类型
- alter table r drop A:删除属性

### 3.3 SQL查询基本结构

基本结构：
$$
select\ &A_1,A_2,...A_n\\
from\ &r_1,r_2,...r_n\\
where\ &P;
$$


- 可以select distinct/all 表示是否有重复元素。默认为all

- 支持的运算符：and、or、 not、<、<=、>、>=、+、-、*、/、=、<>(不等)

### 3.4 附加运算 

1. 更名运算 as:即可以用在select中，也可以用在from子句中，一个重要的应用就是比较同一个关系中的元组，如
   $$
   \begin{align}
   &\pmb{select}\ \ distinct\ \ T.name\\
   &\pmb{from}\ \  instructor \ \ as\ \  T,instructor \ \ as\ \  S\\
   &\pmb{where}\ \ T.salary>S.salary\ \ and\ \ S.dept\_name='Biology';
   \end{align}
   $$

2. 字符串运算：通过**like**来表达模式，也可用**not like**来表示不匹配项，并且模式是大小写敏感的

   - **%**：匹配任意字符串

   - **_(下划线)**:匹配任意字符

   - 可以用**\\**来对某些特殊字符进行转义,并使用关键字**escape**,如 like 'ab\%cd%' escape,匹配以‘ab%cd’开头的字符串？
   
3.  排序：
  $$
  \begin{align}
  &\pmb{select}\ \ *\\
  &\pmb{from} \ \ instructr\\
  &\pmb{order}\ \ by\ \ salary\ \ \pmb{desc},name\ \pmb{asc};
  
  \end{align}
  $$
  
4. 元组形式，可以进行元组赋值，判等

### 3.5 集合运算

注意集合运算默认是去重的，如果想不去重，则需要用到关键字**all**,这一点和select是相反的。

- **union**:并运算
- **intersect**:交运算
- **except**：差运算

例子：
$$
\begin{align}
(&\pmb{select}\ \ course\_id\\
&\pmb{from}\ \ section\\
&\pmb{where}\ \ semester='Fall'\ and \ year=2017)\\
&\pmb{except\ all}\\
(&\pmb{select}\ \ course\_id\\
&\pmb{from}\ \ section\\
&\pmb{where}\ \ semester='Spring'\ and \ year=2018);\\
\end{align}
$$


### 3.6 空值

空值为$null$,SQL提供了一种新的类型$unknown$,,但是与$and,or,not$运算结果是否为$unknown$与具体的逻辑运算符有关(类似于编程语言中的$\&\&和||$

SQL还提供了$is\ null $和$is\ not \ null$。以及$is\ unknown和is\ not\ unknown$来测试一个比较运算的结果是否为$unknown$,含有$null$的重复元组会被去重(使用$distinct$时)



### 3.7 聚集函数

- 平均值：**avg**
- 最小值:**min**
- 最大值:**max**
- 总和:**sum**
- 计数:**count**，若要去重，可以**select count(distinct A)**

#### 3.7.2 分组聚集

group by可以对元组进行分组然后使用聚集函数

**查找每个系的平均工资**
$$
\begin{align}
&\pmb{select}\ dept\_name,\pmb{avg}(salary)\ \pmb{as}\ avg\_salary\\
&\pmb{from}\ instructor\\
&\pmb{group\ by}\ dept\_name
\end{align}
$$
注意，出现在select中的但没有出现在group by中的那些属性，只能作为聚集函数的参数，否这样的查询就是错误的。

#### 3.7.3 having子句

有时候，对分组进行条件限定比对元组限定条件更有用。于是诞生了SQL的having子句

与select类似，任何出现在having中，没出现在group by中的属性，必须出现在聚集函数中。

**eg**:**对于**在2017年**讲授的每个课程**，如果该课程至少有两名学生选课，**找出**选修该课的**所有学生的总学分的平均值**


$$
\begin{align}
&\pmb{select}\ course\_id,semester,year,sec\_id,\pmb{avg}(tot\_cred)\\
&\pmb{from}\ student,takes\\
&\pmb{where}\ student.ID=takes.ID\pmb{\ and}\ year=2017 \\
&\pmb{group\ by}\ course\_id,semester,year,sec\_id\\\
&\pmb{having\  count}\ (student.ID)>=2;
\end{align}
$$


### 3.8 嵌套子查询(重难点)

#### 3.8.1 集合成员资格

可以用in/not in +子查询结果

#### 3.8.2 集合比较

**至少某一个：**

$<some,<=some,>=some,=some,<>some$,其中$=some$等价于$in$,但是$<>some$并不等价于$not\ in$,

**所有：**

$<all,<=all,>all,>=all,<>all$,$<>all等价于not\ in$，但是$=all$并不等价于$in$（比in更强）



#### 3.8.3 空关系测试

检测一个子查询结果是否包含元组，可用$exists/not\ exists$

一个重要用法：
$$
B\subseteq A等价于not \ exists(B\ except\ A) 
$$
例子：找出选修了Biology系的所有课程的学生
$$
\begin{align}
&\pmb{select}\ S.ID,S.name\\
&\pmb{from}\ student \ \pmb{as}\ S\\
&\pmb{where\ not\ exists}((\pmb{select}\ course\_id\ \pmb{from}\ course\ \pmb{where}\ dept\_name='Biology')\\
&(\pmb{select}\ T.course\_id\ \pmb{from}\ takes\pmb{\ as}\ T\  \pmb{where}\ S.ID=T.ID)) 
\end{align}
$$


#### 3.8.4 重复元组存在性测试

####3.8.5 from中的子查询

#### 3.8.6 with子句

#### 3.8.7 标量子查询

### 3.9 数据库的修改

1. **删除**
2. **插入**
3. **更新**



## 第四章 中级SQL

### 4.1 连接表达式

#### 4.1.1 自然连接

**自然连接：**自然连接只考虑两个关系模式中都出现的属性上取值相同的元组。
$$
student \pmb{\ natural \ join}\ takes
$$


查询已经选课的学生可简写为
$$
\begin{align}
&\pmb{select} \ name \,course_id\\
&\pmb{from}\ student\ \pmb{natural\ join} \ takes;
\end{align}
$$




一般情况下的写法：
$$
\begin{align}
&\pmb{select}\ A_1,A_2,...A_n\\
&\pmb{from}\ r_1\ \pmb{natural\ join\ r_2\ natural\ join ...natural\ join}\ r_m\\
&\pmb{where}\ P;
\end{align}
$$
为了避免
$$
\begin{align}
&from\ student\ natural \ join\ takes,course\\
和\\
&from \ student\ natural\ join\ takes\ natural\ course
\end{align}
$$
的区别，SQL提供了一种自然连接的构造形式，它允许你来指定究竟哪些属性相等。

即$r_1\ join \ r_2\ using(A_1,A_2)$,用于指定属性相同进行连接。
$$
\begin{align}
&\pmb{select}\ name,title\\
&\pmb{from}\ student\ \pmb{nartual\ join}\ takes\ \pmb{join}\ course\ \pmb{using}\ (course\_id);
\end{align}
$$

#### 4.1.2 连接条件

另一种连接条件形式：
$$
r_1\ join\ r_2\ on\ P 
$$
on条件可以表达任何SQL谓词，因此比自然连接更为丰富。

#### 4.1.3 外连接

## 第六章 形式化关系查询语言

###  6.1 关系代数

关系代数提供了一组运算，它们以一个或多个关系为输入，并返回一个关系作为输出，诸如SQL这样的实际查询语言是基于关系代数的，但它们增加了许多有用的语法特征。 

关系代数针对的关系是集合，因此没有重复元素。

1. 选择：$\sigma_{dept\_name=building}(department)$

2. 投影：$\Pi_{ID,name,salary}(instructor)$

3. 关系复合运算

4. 笛卡尔积：$r_1\times r_2$:这里的笛卡尔积是两个元组拼接成一个元组

5. 连接运算:$r\bowtie_{\theta} s\Leftrightarrow \sigma_{\theta}(r\times s)$,省略掉$\theta$即为自然连接

6. 集合运算：$\cap(交),\cup(并，并的时候两个关系必须有相同的数量，并且必须满足属性相容),-(差)$

7. 赋值运算：关系名$\leftarrow\ r$

8. 更名运算：$\rho_x(E)$,将关系E重命名为x，另一种用法可以更改属性名，即$\rho_{x(A_1,A_2,...A_n)}(E)$
  - 例子：查找比ID为12121的教师工资高的教师的ID和姓名
    $$
    \Pi_{i.ID,i.name}((\sigma_{i.salary>w.salary}(\rho_i(instructor)\times\sigma_{w.id=12121}(\rho_w(instructr))))
    $$



## 第七章 使用E-R模型的数据库设计

### 7.1 设计过程

概念设计--功能需求规格说明--逻辑设计阶段--物理设计阶段

- **逻辑设计**：将高层概念映射到将被使用的数据库系统具体实现的数据模型。数据模型的实现通常是关系数据模型，并且该阶段通常包含将采用实体-关系模型定义的概念模式映射到关系模式。
- **物理设计**：

### 7.5 主码

#### 7.5.3 弱实体集

**弱实体集**的存在依赖于另一个实体集，称其为**标识性实体集**；我们使用标识性实体集的主码以及称为**分辨性属性**的额外属性来唯一地标识弱实体，而不是将主码和弱实体相关联。非弱实体集的实体集被称为强实体集。

每个弱实体必须和一个标识性实体相关联；也就是说,弱实体集被称为**存在依赖**于标识性实体集。标识性实体集被称为**拥有**它所标识的实体集。将弱实体集与标识性实体集相关联的*联系*被称为**标识性联系**，这样的联系集是多对一的，没有描述性属性，并且弱实体集一方(多的一方)必须全部参与。



### 7.6 从实体集中删除冗余属性

对于一个联系集，如果关联实体集$r_1,r_2$,并且他们均包含公共属性集$S$,主码中不包含$S$的实体集中，$S$属性集是冗余的，需要从中删除。



### 7.7 将E-R图转化为关系模式(较为重要)

#### 7.7.1 强实体集的转化

模式的主码就是强实体集的主码，属性也一样。

#### 7.7.2 复杂属性的强实体集的表示

- **复合属性**:不为复合的子属性单独创一个属性。

- **派生属性**：并不显示表示出来，可以被计算。

- **多值属性**：不同于其他属性处理方式，对于一个多值属性$M$,我们构建关系模式$R$,该模式对应于$M$的属性$A$,以及对应于$M$所在的实体集或联系集的主码的属性。

  例子：对于instructor中的多值属性phone-number，我们可以创建一个关系模式：
  $$
  instructor\_phone(\underline{ID},\underline{phone\_number})
  $$

​		该关系模式的每一个元组都对应于一个电话号码的值,且该关系模式的主码为其所有属性。

若一个关系模式只有一个主码和一个多值属性，我们可以删除这个关系。只保留其多值属性对应的关系模式。



#### 7.7.3 弱实体集的表示

设$A$是具有属性$a_1,a_2,...a_m$的弱实体集，$B$是$A$依赖的强实体集，有属性$a_1,a_2,....a_n$。

对于弱实体集转化而来的模式，该**模式的主码**由其**强实体集的主码**和**弱实体集的分辨符**组成。除了主码，还需要检录A上的外码约束，指明$b_1,b_2...b_n$中引用关系$B$的主码。



#### 7.7.4 联系集的表示

设$R$是联系集，设$a_1,a_2,...,a_m$是每个参与R的实体集的主码的并集所构成的集合，并设$R$的描述性属性（如果有）为$b_1,b_2....b_n$。我们用名为$R$的关系模式表示联系集，R的每个属性表示下述集合的一个成员：
$$
\{a_1,a_2...a_m\}\cup\{b_,b_2....b_n\}
$$
主码选择：将映射关系多的一方的主码设为关系模式的主码

外码：对于每个参与的实体集$E_i$,从其主码导出的$R$的属性引用表示$E_i$的关系模式的主码。

#### 7.7.5 模式的冗余

由上述弱实体集的表示可知，连接弱实体集与其对应的强实体集的练习机的关系模式必定是冗余的，而且在基于E-R图的关系数据库设计中不会给出。



#### 7.7.6 模式的合并

考虑从实体集$A$到实体集$B$的多对一联系集$AB$。假设$A$是全部参与的，则可以将$A$和$AB$合并成单个模式，其主码就为$A$的主码。



## 第八章 关系数据库设计(重难点)

###  8.1 好的关系设计的特点

#### 8.1.1 分解

**有损分解（lossy decomposition）**：分解后产生了多余的元组，反而缺少了识别某个特定实例的信息。

**无损分解（lossless decomposition）**：分解后没有信息丢失

#### 8.1.2 无损分解

令$R$为关系模式.$R_1,R_2$为$R$的分解。若果用两个关系模式$R_1,R_2$去代替$R$没有信息丢失，则称该分解为一个**无损分解**。

即若果对于任何合法实例，关系r都包含与下列查询相同的元组结果，称分解为无损的：
$$
\begin{align}
&\pmb{select\ *}\\
&\pmb{from} (\pmb{select\ R_1\  from\ r})\ \pmb{nartual\ join}(\pmb{select\ R_2\  from\ r}) 
\end{align}
$$
关系代数表示更加简洁
$$
\Pi_{R_1}\bowtie\Pi_{R_2}=r
$$
即投影后的自然连接必须等于原关系模式。

若
$$
r\subset\Pi_{R_1}\bowtie\Pi_{R_2}=r
$$
则分解是有损的



### 8.2 使用函数依赖进行分解(重点)

一个关系的满足所有真实世界约束的实例被称为**合法实例(legal instance)**

#### 8.2.1 符号惯例

- 一般用希腊字母表示属性集，如$\alpha$,大写罗马字母表示关系模式，$r(R)$表示模式$R$是相对于关系$r$的
- 超码用$K$来表示，如"$K$是$R$的一个超码"
- 关系使用小写字母，$r(R)$表示具有模式$R$的关系$r$
- 关系在任意时刻有一个特定的值，称为r的关系实例，一般也可以用关系名表示其实例。

#### 8.2.2 码和函数依赖

**超码**：在$r(R)$的任意合法实例中，任意一堆元组对$t_1.t_2$,若$t_1\neq t_2$,则$t_1[K]\neq t_2[k]$。则$K$为超码(不存在在$K$上相同的两个不同元组)

对于一个关系模式$r(R),\alpha \subset R,\beta \subset R$,

- 给定一个R的实例，如果对于任意元组对，$t_1,t_2,t_1[\alpha]=t_2[\alpha]$,则$t_1[\beta]=t_2[\beta]$也成立，则称该实例**满足函数**依赖$\alpha \rightarrow \beta$

- 如果$r(R)$的每个合法实例都满足函数依赖$\alpha \rightarrow \beta$，则称该函数依赖在模式$r(R)$上成立

  

有了函数依赖，则超码可以定义为：

如果函数依赖$K\rightarrow R$在$r(R)$上成立，则$K$是$r$的一个超码。

**平凡（trival)函数依赖**：被所有关系都满足的函数依赖，如$A\rightarrow A$。若$\beta\subset \alpha$,则$\alpha\rightarrow \beta$也是平凡的。

**函数依赖的闭包：**用$F^+$表示集合$F$的**闭包(closure)**，即给定的$F$能推出 的所有函数闭包的集合。





### 8.3 范式

  #### 8.3.1 Boyce-Codd范式(BCNF)

**定义：**对于$F^{+}$的任意形如$\alpha \rightarrow\beta$的函数依赖，下面至少有一项成立：

- $\alpha \rightarrow\beta$是平凡的函数依赖(即$\beta \subseteq\alpha$)
- $\alpha$是一个超码

数据库构成BCNF就是所有模式均为BCNF。

#### 8.3.2 第三范式

**候选码**：最小的超码，其任何子集都不是超码。

**3NF**：对于$F^{+}$的任意形如$\alpha \rightarrow\beta$的函数依赖，下面至少有一项成立：

- $\alpha \rightarrow\beta$是平凡的函数依赖(即$\beta \subseteq\alpha$)
- $\alpha$是一个超码
- $\beta-\alpha$中的每个属性$A$都被包含于$R$的一个候选码中。

第三条是BCNF的小放松，确保每一个模式都能保持依赖的分解到3NF.

特定情况下，函数依赖来分解模式可能无法避免不必要的信息重复。

### 8.4 函数依赖理论(重点)

#### 8.4.1 函数依赖集闭包

给定函数依赖集$F$，则$F$所蕴含的所有函数依赖的集合称为$F$的闭包，记做$F^{+}$，为了求闭包，有以下公理

**阿姆斯特朗公理**：

- **自反律**：若$\alpha$为一个属性集且$\beta \subseteq \alpha$,则$\alpha\rightarrow\beta$成立
- **增补率**：若$\alpha\rightarrow\beta$成立且$\gamma$为一个属性集。则$\gamma\alpha\rightarrow \gamma \beta$成立($xy相当于x\cup y$)
- **传递率**：若$\alpha\rightarrow\beta$成立且$\beta\rightarrow\gamma$成立,则若$\alpha\rightarrow\gamma$成立



附加规则(方便计算闭包，可由上述定理推出):

- **合并率**:若$\alpha\rightarrow\beta$成立且$\alpha \rightarrow\gamma$成立,则$\alpha \rightarrow \beta\gamma$成立
- **分解率:**若$\alpha \rightarrow \beta\gamma$成立，则$\alpha\rightarrow\beta$成立且$\alpha \rightarrow\gamma$成立,
- **伪传递率:**若$\alpha \rightarrow \beta$成立且$\gamma \beta\rightarrow\delta$成立。则$\alpha \gamma\rightarrow \delta$成立

#### 8.4.2 属性集的闭包

若果$\alpha \rightarrow B$，则称B是被$\alpha$决定。所有$\alpha$所决定的属性的集合称为属性集$\alpha$的闭包，记做$a^{+}$

方法也很简单。直接利用当前被决定的属性去函数闭包$F^{+}$中添加能被蕴含的新的属性集即可。

**作用**

- 测试$\alpha$是否为超码。只需要看$\alpha^+$是否为$R$即可
- 检测$\alpha \rightarrow \beta $是否成立(这个很重要很方便)
- 提供了计算函数依赖闭包的另一种方式。即对于$任意\gamma \subseteq R$,求出$\gamma $闭包。对于任意$S \subseteq \gamma^+$，输出函数依赖$\gamma \rightarrow S$



#### 8.4.3 正则覆盖

如果可以去除函数依赖的一个属性而不改变该函数依赖集的闭包，则称该属性是**无关**的。**无关属性(extraneous)**形式化定义如下

考虑函数依赖集$F$的一个函数依赖$\alpha \rightarrow \beta$:

- **从左侧移除**(左侧移除后会得到更强的，所以F蕴含这个更强的话则是无关的)：如果$A\in \alpha $并且$F$逻辑蕴含$(F-\{\alpha-\beta\})\cup \{(\alpha-A)\rightarrow \beta\}$，则称属性$A$在$\alpha$中无关。
- **从右侧移除:**(右侧移除后会得到更弱的，所以如果这个更弱的逻辑蕴含F的话，则在右侧无关)： 如果$A\in \beta $，并且函数依赖集$(F-\{\alpha \rightarrow \beta\})\cup \{\alpha\rightarrow (\beta -A)\}$逻辑蕴含F，则属性A在$\beta$中是无关的。

**有效地检验一个属性是否无关**：

对于$\alpha \rightarrow \beta$中的一个属性A:

- 若$A\in \beta$,考虑集合
  $$
  F'=(F-\{\alpha \rightarrow \beta\})\cup \{\{\alpha\rightarrow (\beta -A)\}
  $$
  若$\alpha\rightarrow A$可以由$F'$推出，则说明是无关的(通过计算$F'下\alpha$的属性闭包即可)
  
- 若$A\in \beta$，令$\gamma =\alpha-\{A\}$，并检查$\gamma \rightarrow \beta $可以由$F$推出，则为无关。



$F$的正则覆盖$F_c$是这样一个函数依赖集：$F$逻辑蕴含$F_c$中所有的依赖，并且$F_c$逻辑蕴含$F$中的依赖(等价)。此外，$F_c$必须具备下列性质

- $F_c$中的任何函数依赖都不包含无关属性
- $F_c$中的每个函数依赖的**左侧都是唯一的**。

**正则覆盖的求法：**

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230127191533754.png" alt="image-20230127191533754" style="zoom: 67%;" />



此外，需要注意的是，正则覆盖**并不是唯一的**。



一个例子：

<img src="D:\Markdown\md\期末复习\images\11.jpg" style="zoom: 55%;" />



#### 8.4.4 保持依赖

看不太懂，明天再来



### 8.5 使用函数依赖的分解算法

#### 8.5.1 BCNF分解



#### 8.5.2 3NF分解

### 8.6 多值依赖(了解)

### 8.7 其他范式(2NF要了解一下，老教师可能出)

1NF:

2NF:

4NF:





## 第十二章 查询处理和查询优化

## 第十三章 事务管理

## 第十四章 并发控制与恢复
