##第一章 计算机网络和因特网

### 1.1 因特网

一些概念：

- **因特网**：一个互联了遍及全世界的数亿计的计算机设备的网络
- **端系统/主机**：连接到因特网中的各种设备。
- 端系统通过**通信链路**和**分组交换机**（packet switch）连接，分组交换机包括**路由器**(router)和**链路层交换机**(link-layer-switch)
- 端系统通过**因特网服务提供商（ISP)**接入因特网
- 因特网的标准由**因特网工程任务组（IETF）**研发，IETF的标准文档称为**请求评论（RFC）**
- **协议：**一个协议定义了在两个或者多个通信实体之间交换的报文格式和次序，以及报文发送/接收一条报文或其他事件所采取的行动。

### 1.2 网络边缘

网络边缘指网络中的各个端系统以及边缘路由器，端系统又称为主机，主机又分为**服务器**和**客户**。

#### 1.2.1 接入网

接入网：指将端系统连接到其边缘路由器的物理链路。

1. 家庭接入：DSL（数字用户线），电缆，FTTH（光纤到户）,拨号和卫星。HFC:(混合光纤同轴)
2. 企业（和家庭）接入：以太网(双绞铜线)和WIFI（无线LAN）
3. 广域无线接入：3G和LTE

#### 1.2.2 物理媒体

双绞铜线、同轴电缆、光纤、陆地无线电信道、卫星无线电线道



### 1.3 网络核心

**网络核心**：即由互联因特网端系统的**分组交换机**和**链路**构成的网状网络。

**传输(transmission)：**将分组向链路输出

**传播（propagation）：**分组在链路中传输

**带宽**：链路的传播速率

**存储转发传输：**指交换机开始向输出链路传输该分组的第一个比特之前，必须接收整个分组。

在这种模式下的时延分析：

<img src="images/5.jpg" style="zoom: 33%;" />



#### 1.3.2 电路交换

和**分组交换**(packet switching)不一样，**电路交换**（circuit switching）网络中，在端系统通信会话期间，预留了端系统间通信沿路径所需要的资源(缓存，链路传输速率)，而在分组交换中是不会预留这些资源的。

1. **频分复用（Frequency-Division-Multiplexing）**或**时分复用Frequency-Division-Multiplexing）**。对于FDM，每条链路连续的得到部分带宽。而在TDM中，时间被划分为固定区间的帧，每帧又被划分为固定数量的时隙。每条电路在短时间间隔（即时隙）中周期的得到所有的带宽。
2. 分组交换的优点：

- 它提供了比电路交换更好的带宽共享
- 他比电路交换更简单吗，更有效，实现成本更低。

### 1.4 分组交换中的时延、丢包和吞吐量（考试重点）

#### 1.4.1 分组交换中的时延类型

1. **处理时延:**检查分组首部决定该分组导向何处所需要的时间时处理时延的和一部分。
2. **排队时延**：分组在缓存队列中排队的时延。
3. **传输时延(transmission delay)：**将分组所有比特推向链路所需要的时间。级别通常为毫秒到微秒级别。
4. **传播时延(propagation delay)：**从起点路由器到终点路由器传播所需要的时间。级别通常为毫秒级别。
5. **传输时延和传播时延的区别**：传输时延时路由器将分组推向链路所需要的时间，它是分组长度和链路传输速率的函数；而传播时延时一个**比特**从一台路由器到另一台路由器的传播所需要的时间，它是两台路由器之间的距离的函数，与分组长度和链路传输速率无关。

**结点总时延**：
$$
d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}
$$


#### 1.4.2 排队时延和丢包

**流量强度**：a表示分组到达队列的的平均速率（单位为pkt/s）,假定所有分组都是L比特，则比特到达队列的平均速率为La **bps**

假设队列能容纳无穷大的比特数量，则**La/R**被称为**流量强度**。

一个原则：流量强度**不能大于1**

**丢包**：实际上缓存队列并不能无限大，随着流量强度趋向1，排队时延并不实际趋向无穷大，相反，由于没有地方存储这个分组，路由器将丢弃该分组。一个结点的性能并不仅仅根据时延来度量，而且根据分组丢失的概率来度量。



#### 1.4.3 端到端时延

假设源主机和目的主机有N-1台路由器，并且网络无拥塞(不考虑排队时延)，
$$
d_{end-end}=N(d_{proc}+d_{trans}+d_{prop})
$$


#### 1.4.4 计算机网络中的吞吐量

假设传输的文件为F比特，并且另一个主机接收到所有比特用了B s,则**平均吞吐量(average throughtput)**为**F/T bps**.。

设在客户端和服务器有N条链路，每条链路传输速率为$R_1,R_2...,R_N$,则从服务器到客户端的文件传输吞吐量为：
$$
min\{R_1,R_2....,R_N\}
$$
即为文件传输中的**瓶颈链路**

### 1.5 协议层次

**因特网协议栈：**

1. **应用层**：应用层是网络应用程序及它们的应用层协议存留的地方。包括的协议：HTTP，FTP,SMTP。应用层协议分布在多个端系统上，分组称为**报文(message)**。
2. **传输层**：因特网的传输层在应用层序端点之间传送应用层报文。协议有TCP,UDP。分组称为**报文段(segment)**
3. **网络层**：因特网的网络层负责将称为**数据报(datagram)**的网络层分组从一台主机移动到另一台主机，协议有IP协议,以及一些路由选择协议。
4. **链路层：**因特网的网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个结点(主机或者路由器)移动到路径上的下一个结点，网络层将数据报下传给链路层，链路层沿着路径将数据传递给下一个结点。分组称为**帧(frame)**
5. **物理层：**与链路层将帧移动到下一个结点不同，而物理层的任务是将该帧中的**一个一个比特**从一个结点移动到下一个结点。

除了因特网协议栈，还有**OSI(open systems internet**)协议栈。



## 第二章 应用层

### 2.1 应用层协议原理

#### 2.1.1 网络应用程序体系结构

- **客户服务器体系结构：**在这种体系结构下，有一个总是打开的主机称为服务器，它服务与其它主机的请求。客户之间不能直接进行通信。C-S体系结构的一个特点就是服务器具有**固定的、周知的**地址，该地址称为**IP地址。**并且服务器总是打开的。具有该体系的应用程序有：Weeb,FTP，Telnet,和电子邮件。为了避免一台单独的服务器跟不上它所有客户请求，配备大量主机的**数据中心**常被用于创建强大的虚拟服务器。
- **P2P体系结构**：在这个体系结构下，对位于数据中心的专用服务器有最小(或者没有)的依赖，相反，应用程序在间断连接的主机对之间使用直接通信，这些主机被称为对等方。特点是**自扩展性**

#### 2.1.2 进程通信

**客户和服务器进程**

网络应用的通信实际上是应用进程之间的通信，

在给定的一对进程之间的通信会话场景中，发起通信的进程被标识为**客户**，在会话开始时等待联系的进程 是**服务器**。



**套接字**：进程通过一个称为**套接字(socket)**的软件接口向网络发送报文和从网络接收报文，套接字是同一台主机应用层和运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也被称为应用程序和网络之间的**应用程序编程接口(API)**。



**进程寻址**：需要两种信息：(1) 主机地址（**IP地址**） (2) 目的主机中接收进程的标识符，即**端口号**。



#### 2.1.3 可供应用程序使用的运输服务

1. **可靠数据传输(reliable data transfer)**
2. **吞吐量(throughput)**
3. **定时(timing)**
4. **安全性(security)**

#### 2.1.4 因特网提供的运输服务

**TCP服务**：面向连接，提供可靠数据传输，以及有拥塞控制机制。其中**安全套接字层（SSL）**是TCP加强版，除了提供了TCP的服务，还能进行加密。

**UDP服务**：是一种无连接，并且提供不可靠的数据传送服务，他仅提供最小服务，是一种轻量级的运输层协议。



**流行的应用及其协议**

|     应用     | 应用层协议 | 支撑的运输协议 |
| :----------: | :--------: | :------------: |
|   电子邮件   |    SMTP    |      TCP       |
| 远程终端访问 |   Telnet   |      TCP       |
|     Web      |    HTTP    |      TCP       |
|   文件传输   |    FTP     |      TCP       |
|  流式多媒体  |    HTTP    |      TCP       |
|  因特网电话  |    SIP     |    TCP/UDP     |





### 2.2 WEB和HTTP(重点)

#### 2.2.1 http概述

Web的应用层协议时**超文本传输协议(Hypertext Transfer Protocol)**,由两个程序实现，一个客户程序和一个服务器程序。

一个Web页面包含诸多如html、图片、程序、视频的文件对象，每个文件对象可以通过一个**URL**来寻址。并且HTTP是一个**无状态协议**，即http服务器并不保存关于客户的任何信息，并且Web服务总是打开的。



#### 2.2.2 非持续连接和持续连接

1. - **非持续连接：**客户端首先发起一个TCP连接与服务器建立连接,连接后发起HTTP请求，服务器返回数据对象后，客户端会告诉服务器关闭该TCP连接，后续传输需要重新建立连接。
   - **往返时间（Round-Trip Time,RTT)**：一个短分组从客户端到服务器然后再返回给客户所花费的时间。
   - 粗略的讲，对于非持续性连接，请求一个html对象的时间为2个RTT时间+文件传输时间
   - **缺点**:(1) 需要为每一个请求对象建立和维护一个全新的连接。每个连接在客户和服务器中都要分配**TCP缓冲区**和保持**TCP变量**，给Web服务器带来了严重的负担。(2) 每次需要一个RTT建立连接，时延更大


2. **持续连接**：服务器在响应后，保持TCP连接打开，在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。

**HTTP**默认使用**带流水线的持续连接**。



#### 2.2.3 HTTP报文格式

**1. HTTP请求报文：**

```http
GET /home/index.html HTTP/1.1
Host: www.someschool.edu
Connection:close
User-agent: Mozilla/5.0
Accept-language: en
```

第一行称为**请求行**，后继行叫做**首部行**。请求行有三个字段：**方法字段**，**URL**字段和**HTTP版本**字段。

<img src="images/6.jpg" style="zoom: 25%;" />

**方法字段**：

- **GET：**最常用的，用于想服务器请求数据。
- **POST:**通常用向服务器提交表单内容，内容在**实体体(entity body)**里面(GET时实体体为空)。当然，GET也可以提交表单，可以在路径后面加$？r_1\&r_2....$,
- **HEAD**：请求对象的首部，通常用于调试跟踪。
- **PUT:**向服务器上传对象到指定的路径。
- **DELETE**:删除web服务器上的对象。

**Host**：指明主机名。

**Connection:**close表示使用非持续连接，默认是持续连接。

**User-agent**指出发起请求的客户的浏览器类型。

**Accept-langauge**指明用户想得到的该对象的语法版本。



**2. HTTP响应报文**

```http
HTTP/1.1 200 OK
Connection: close
Date: Tue,24 Jan 2023 22:55:00 GMT
Server: Apache/2.2.3
Last-Modifyed: Tue,24 Jan 2023 22:56:00 GMTT
Content-Length: 1000
Content-Type: text/html
```

有三个部分，一个初始**状态行**，一个**首部行**，然后是**实体体**，用来存放数据

**状态行：**由**协议版本**，**状态码**，以及**短语**组成。常见状态码和短语如下：

- **200 OK**:请求成功，数据在返回的响应报文中。
- **301 Moved Permanently**:请求的对象已经被永久转移了，URL在响应报文中。
- **304 Not Modifyed**:在条件GET中，初始服务器向代理服务器标识文件没有被修改，可以直接转发代理服务器中对象的缓存副本
- **400 Bad Reques**t:一个通用差错代码，表示该请求不能被服务器理解。
- **404 Not Found**:被请求的文档不在服务器上
- **505 HTTP Version Not Supported**:服务器不支持请求报文使用的HTTP版本。

**首部行：**

- **Connection**：close告诉客户发送完报文后关闭连接
- **Date**：服务器发送报文的时间
- **Serve**r:服务器类型，类似于请求报文中的User-Agent
- **Last-Modifyed**:对象创建或者修改的最后时间。
- **Content-Length**:被发送对象的字节数。
- **Content-Type**:对象类型



通用格式如下：

<img src="images/7.jpg" style="zoom: 20%;" />





#### 2.2.4 用户和服务器的交互：cookie

为了解决HTTP的无状态，引入了cookie,可以用于标识一个用户。在初次访问浏览器时需要提供一个用户标识，在后继会话中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户。因此cookie可以在HTTP上建立一个用户会话层。cookie有四个组件

- 在HTTP响应报文中的一个cookie首部行
- 在HTTP请求报文中的一个cookie首部行
- 在用户客户端系统中保留一个cookie文件，由用户浏览器管理。
- 位于web站点的一个后端数据库。



#### 2.2.5 web缓存

**web缓存**又叫**代理服务器**，能够代表**初始Web服务器**来满足HTTP请求的网络实体，并且既是服务器又是客户。

web缓存可以缓存对象副本，当客户发起请求，如果副本在代理服务器，则直接发送给客户，否则像初始服务器发送http请求文件，再发给客户。

部署Web缓存其的原因

- Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存之间的瓶颈带宽更是如此。
- Web缓存器能够大大减少一个机构的接入链路到因特网的的通信量。通过减少通信量减少了费用
- Web缓存器能从整体上大大减低因特网上的流量，从而改善所有应用的性能。

**内容分发网络(content distribution network CDN)**。

#### 2.2.6 条件GET方法

为了解决缓存器副本陈旧的问题，引入了条件GET

如果请求报文中有一条"**If-Modified-Since"**首部行，则为**条件GET请求报文。**Web服务器会检查该首部行后面的时间与最近修改时间对比，如果没有修改，Web服务器向缓存器发送的响应报文包含**304 Not Modified**(并不会包含对象，会浪费带宽),说明文件没有修改。缓存器直接发给客户，否则需要向缓存器发送最新对象副本。

### 2.3 文件传输协议(FTP)

FTP是**有状态的**，并且是非持续链接。使用了两个并行TCP连接，**控制连接和数据连接**

控制端口：21

数据端口：20

其他邮件协议：POP3，IMAP(因特网邮件访问协议)

### 2.4 因特网中的电子邮件

SMTP：一个推协议，而HTTP是一个拉协议。

### 2.5 DNS:因特网的目录服务(较为重要)

主机的两种标识:**主机名和IP地址**

#### 2.5.1 DNS提供的服务

域名系统Domain Name System):实现主机名到ip地址转换的目录服务。

- 是一个由分层的**DNS服务器**实现的分布式数据库
- 一个使得主机能够查询分布式数据库的应用层协议
- DNS运行在UDP之上，使用53号端口
- 是被其他应用层协议使用的协议

除了进行主机名到IP地址的转换，DNS还提供以下重要服务：

- **主机别名**:有时一个主机的名字很复杂，存在其他**别名**，复杂的名字称为**规范主机名**。
- **邮件服务器别名**
- **负载分配：**DNS也用于在冗余的服务器之间进行负载分配。繁忙的站点被冗余分部在多台服务器上，每台服务器均运行在不同的端系统上，每个都有这不同的IP地址。

#### 2.5.2 DNS工作原理概述

主机-调用DNS客户端-向DNS服务器请求-DNS服务器返回捷信后的ip地址

DNS一种简单设计时因特网上只使用一台DNS服务器，缺点如下

- 单点故障
- 通信容量很大
- 远距离的集中的数据库
- 难以维护

1. 分布式、层次数据库

   <img src="images/12.jpg" style="zoom: 33%;" />

   - **根DNS服务器：**因特网有13个根DNS服务器
   - **顶级域(Top-Level Domain)服务器：**负责顶级域域名如com、org、net、edu、gov、net，以及所有国家的顶级域名如uk、fr、ca、cn、jp等等。
   - **权威DNS服务器：**在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。

   上述出于DNS服务器的层次结构中。在这之外，还有一种重要的服务器：**本地DNS服务器**。每个ISP都有一台本地DNS服务器(起代理的作用)。

   流程如下：

   <img src="images/13.jpg" style="zoom:50%;" />

2. **DNS缓存：**为了改善时延并减少在因特网上到处传输的DNS报文数量，引入了DNS缓存技术。DNS服务器能够将回答中的信息缓存在本地存储器中。由于主机名到IP地址的映射并不是永久的，DNS服务器在一段时间后将丢弃缓存的信息。（缓存是为了性能，删除是为了一致性）



#### 2.5.3 DNS记录和报文

DNS存储了**资源记录(resource record**)，每一个RR是一个包含了下列字段的四元组
$$
(Name,Value,Type,TTL)
$$

- TTL：记录生存的时间
- 若Type=A,则Name是主机名，Value是对应的IP地址。
- 若Type=NS，则Name是个域(如foo.com),而Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。
- 如果Type=CNAME，则Value是**别名**为Name对应主机的规范主机名。(主机别名到规范名的映射)
- 如果Type=MX，则Value是别名为Name的**邮件服务器的规范主机名**。

当你注册一个公司的域名后，你需要向注册登记机构提交申请，必须提供你的基本和辅助quanweiDNS服务器的名字和IP地址，该机构会想TLD服务器(如com)中插入一条NS记录和一条A记录，对应于该域中主机的权威DNS服务器主机名字和其IP地址。

### 2.6 P2P（了解一下即可）





## 第三章 传输层(重难点)

### 3.1 概述和运输服务

**运输层作用**：为运行在不同主机上的应用进程之间提供了**逻辑通信**，网络层提供了主机到主机的逻辑通信。运输层在端系统中实现，而网络层是在路由器中实现。

**运输层协议和提供的服务**：协议有UDP和TCP协议，二者最基本的责任是：将两个端系统间的IP的交付服务(一种不可靠服务)扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程交付被称为运输层的**多路复用(multiplexing)**与**多路分解(demultiplexing)**。此外，TCP还提供**可靠数据传输**和**拥塞控制**服务。



### 3.2 多路复用和多路分解

**多路分解**：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。

**多路复用**：在源主机从不同套接字中收集数据块，并未每个数据块封装上首部信息从而生成报文段(segment)，然后将报文段传递到网络层，所有这些工作称为多路复用。

通过**源端口号**和**目的端口号**来确定该报文段要交付的目的套接字。端口号为16比特数，0-1023为**周知端口号(well-known port number)**是首限制的，保留了诸如HTTP(80).FTP(21)等。

**TCP和UDP的套接字:**

- 一个**UDP套接字**由一个**二元组**来全面标识，即**目的IP地址和目的的端口号。**(无连接)
- 一个**TCP套接字**由一个**四元组**标识，包括**源IP地址，源端口号，目的IP地址,目的端口号**(面向连接)
- 注意这里，一个socket通常对应一个进程，但一个进程通常会有多个线程，这些线程之间对应的套接字是不一样的。



### 3.3 无连接运输：UDP

虽然TCP很好，但有时候依旧选择使用UDP的原因：

- 关于何时、发送什么数据的应用层控制更为精细，没有拥塞控制，且能容忍一些数据丢失。
- 无需建立连接，减少时延
- 无连接状态
- 分组首部开销小：TCP首部需要20字节，而UDP仅需要8字节



<img src="D:\Markdown\md\期末复习\images\14.jpg" style="zoom: 25%;" />

#### 3.3.1 UDP报文段结构

首部一共8字节，

- 源端口号(16位)
- 目的端口号(16位)
- 长度(16位)：UDP报文段的字节数，包括首部和数据，因此范围为8~65535
- 检验和(16位)

#### 3.3.2 UDP检验和

将UDP所有字段分成16位求和，溢出的进位也要加到个位，然后将这个和按位取反就得到了校验和。

如果接收方将所有位(包括校验和)按照上述方法加起来，那么的到的值一定全是1，如果某一位出现了0，则说明出现了差错。

UDP提供差错检验是因为不能保证所有链路都提供差错检验，满足了**端到端原则**





### 3.4 可靠数据传输原理(难点)

<img src="D:\Markdown\md\期末复习\images\16.jpg" style="zoom: 20%;" />

#### 3.4.1 构造可靠数据传输协议

##### 3.4.1.1 经完全可靠信道的可靠数据传输：rdt1.0

在这种情况下，**底层信道(网络层及其以下)是完全可靠的**，该协议为rdt1.0

该协议下的**有限状态自动机(FSM)**如下：

<img src="D:\Markdown\md\期末复习\images\15.jpg" style="zoom: 33%;" />

rdt_send由高层的应用层调用，之后rdt发送端打包数据通过udp_sent(发送数据出去)

rdt_rcv为rdt接受方接收底层的分组，再呈现给高层应用层



##### 3.4.1.2 经具有比特差错信道的可靠数据传输：rdt2.0

引入了**肯定确认(ACK)**和**否定确认(NAK)**,当收到NAK后，需要重传，这种协议称为**自动重传请求协议(ARQ)**

ARQ协议还需要另外三种协议功能来处理存在比特差错的情况：

- 差错检测
- 接收方反馈：需要接收方向发送方发送NAK和ACK分组，理论上只需要1个比特，1表示ACK,0表示NAK.
- 重传:接收方收到有差错的分组时，发送方将重传分组。

**FSM：**

<img src="images/17.jpg" style="zoom:20%;" />



当发送方出于等待接收方ACK和NAK时，它不能从上层获取信息，即不能发生rdt_send()，除非发送方确认接收方正确接收分组。像rdt2.0这种协议被称为**停等协议(stop-and-wait)**



rdt2.0协议一个致命的缺陷是：**没有考虑ACK或者NAK分组受损的情况！**因此需要在NAK或ACK分组中添加检验和和其他比特来检测差错。

有一种方法是发送方收到含糊不清的ACK/NAK分组时只需要重传当前数据分组即可。这种方法引入了**冗余分组**，但是冗余分组的根本困难在于接收方不知道它上次发送的ACK/NAK是否被正确的被发送方接收到，因此无法事先知道收到的分组是新的还是重传。



为了**解决这个问题(接收方不知道是否为重传数据还是新的数据)，**几乎所有传输协议都采取了这样的措施：即在**数据分组**中增加新的字段，让**发送方**对数据分组进行编号，将分组的**序号**放在该字段。

如果NAK或者ACK出错，发送方重复发送原分组，序号发生改变，接收方检测到重复分组之后，则会向发送方回复ACK。对于停等协议，只需要1比特的序号即可，接收方可以与最近收到的一次数据的序号进行比对即可(相同即为重传)。

**rdt2.1：引入了序号，重传，校验和**

rdt2.1 发送方FSM:

<img src="images/18.jpg" style="zoom: 27%;" />

rdt2.1接收方FSM:

<img src="images/19.jpg" style="zoom:27%;" />

**rdt2.2**：无NAK(NAK free),使用ACK0或者ACK1来回复(ACK进行编号),即用当前序号的前一个序号来表示NAK，也可以做到表示否定

<img src="images/20.jpg" style="zoom:27%;" />

<img src="images/21.jpg" style="zoom:27%;" />

##### 3.4.1.3 经具有比特差错的丢包信道的可靠数据传输：rdt3.0(比特交替协议)

现在假设除了比特受损之外，分组还会发生**丢包**。

这里采用**超时重传机制**，引入了一个**倒计数计时器**,时间设置为比一个往返时间稍微长一点，发送方能够做到：

- 每发送一个分组，便启动一个计时器
- 响应定时器中断(采取相应的动作)
- 终止定时器

<img src="images/22.jpg" style="zoom:27%;" />



#### 3.4.2 流水线可靠数据传输协议(重点)

发送方的利用率：
$$
U_{sender}=\frac{发送方实际忙于将发送比特送进信道的时间}{发送时间}
$$
对于停等协议，一个数据包传输的$U_{sender}=\frac{L/R}{RTT+L/R}$,这个效率是很低的，实验非常大，

**流水线（pipelining）协议：**允许发送方发送多个分组而无需等待确认。该协议将为可靠数据传输带来下列影响：

- 必须增加序号范围，因为每个传输的分组必须有唯一的序号。
- 协议的发送方和接收方两端必须缓存多个分组。
- 所需序号的范围和对缓冲的要求取决于数据传输协议如何入力丢失、损坏及延时过大的分组。解决流水线的差错恢复的两种基本方法：GBN和SR.

流水线可以显著增加会话的吞吐量。



#### 3.4.3 回退N步(GBN)

GBN发送方窗口大小为N,接收方窗口大小为1

![](images/33.jpg)

序号为$0,1,2....2^n-1,0,1,2...2^n-1,0....$

GBN响应以下三种事件：

- 上层调用。当上层调用rdt_send(）时，发送方检测发送窗口是否已满，即是否有N个发送但未被确认的分组。如果未满，则产生一个分组并将其发送，相应的更新变量。否则将数据返回给上层(即隐含发送窗口已满，等会再试)
- 收到一个ack。GBN中对序号n的确认采用**累计确认**。即n收到，代表n及其以前的都被收到了。
- 超时事件。回退n步的含义是当出现超时或者分组丢失时，发送方会**重发所有发送了但未被确认的分组。**GBN中有一个最早的已发送但未被确认的分组所使用的定时器。如果收到ack,但仍有未被确认的分组，定时器被重新启动，如果没有，定时器被终止。

对于接受方，如果序号n被收到，且上次交付的是n-1,则接受方发送一个ack，将分组递交给上层(等价于窗口长度为1)。对于其他所有情况，接收方丢弃分组，并发送最近按需接受到的分组的ack。



**优点：**接收缓存简单，即接收方不需要缓存任何失序分组，只需要维护下一个期望收到的序号expectedseqnum

**缺点：**会丢弃一个正确接收到的分组，随后对该分组的重传也许会丢失或者出错，引起更多地重传。(单个分组的出错就会造成大量重传)

<img src="images/34.jpg" style="zoom: 25%;" />



​                                                                                                                                                                            

#### 3.4.4 选择重传(SR)

选择重传协议仅重传那些发送方怀疑接收方出错的分组，从而避免不必要的重传。

<img src="images/35.jpg" style="zoom: 40%;" />



​     发送方的动作和事件

-  从生成接收数据，如果序号在窗口内，则发送，否则将数据缓存，
- 超时。这里，**每个分组都有自己的路基定时器。**
- 收到ack,如果序号在窗口内，将分组标记为已接收，**如果序号等于send_base,则窗口基序号移动到最小的未确认分组处。**(非累积确认

接收方动作和事件：

- 接收方将确认一个分组而不管其是否按序
- 序号在$[rcv\_base,rcv\_base+N-1]$中的分组将被正确接收。如果分组序号等于基序号，则该分组和缓存过得连续的徐浩一起被交付给上层，然后基序号移动
- 序号在$[rcv\_base-N,rcv\_base-1]$的分组将被正确收到。这种情况下，需要产生一个ack,即使是接收方已经确认收到的分组。

<img src="images/36.jpg" style="zoom:27%;" />             



发送方和接收方窗口并不一致，因此接收方有时候并不知道哪些是重传的数据，哪些是新的数据。

为了避免这个问题，如果序号有n位，那么,GBN和SR协议来说，发送方得最大窗口分别为$2^n-1$和$2^{n-1}$,才能保证不会产生这种混淆。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

### 3.5 面向连接的运输：TCP(重点)

#### 3.5.1 TCP连接

TCP是**面向连接的**，端系统会保持TCP相关的连接状态，而网络部分不会保存。

TCP连接是**全双工服务的**(A-B,B-A)，也是**点对点的**（单个发送方和单个接收方）。

TCP的**三次握手：**客户首先发送一个特殊的TCP报文段，服务器再回应一个特殊TCP报文段，客户再回应第三个特殊报文段，前两个不包含有效载荷，第三个可以，称为TCP的三次握手。

TCP可以实际从发送缓存中取出并放入报文段的的最大**数据长度(不包含TCP首部)**称为**最大报文段长度(MSS)**,通常根据主机发送的最**MTU**来确定。典型的MSS为1460字节。

TCP连接的组成：一台主机上的缓存、变量和进程套接字以及另一台主机上的缓存、变量和进程套接字，而主机间的网络元素(路由器，交换机)没有为该连接分配缓存和变量。

TCP也是**累计确认的**

#### 3.5.2 TCP报文段结构

<img src="images/37.jpg" style="zoom:27%;" />



- 源端口号和目的端口号：被用于多路复用/分解到应用层进程
- 检验和：检验差错，和UDP一样
- 32比特序号和32b比特确认号（最重要）：TCP的序号是针对字节的，而不是分组。TCP对每个字节编号，一个报文段的序号表示每个报文段**数据部分**的首字节编号。确认号表示主机期望从另一个主机收到的下一个字节的序号(类似于GBN的接收方窗口的expecterseqnum).TCP也是采用**累计确认**的。
- 接收窗口：用于流量控制，指示接收方愿意接接收的字节数量。
- 4比特的首部长度：指示了以32比特(4字节)为单位的首部长度，一般为5，即20字节(选项字段为空)
- 可选与变长的选项字段
- 6比特标志字段：ACK比特用于只是确认字段中的值是否有效。RST，SYN,FIN用于连接的建立和拆除。PSH比特被设置，指示接收方将数据交付给上层。URG指示数据为紧急数据，

当主机收到一条时序报文段时，TCP并没有明确指出做法，而是把t它交给TCP编程人员去处理。

一条TCP连接的初始序号往往是随机选择，不一定是0，可以减少将那些仍在网络中存在的来自两台主机之间的先前已终止的连接的报文段，误认为是这两台主机之间新建立的连接所产生的有效报文段的可能性。

#### 3.5.3 往返时间的估计与超时

**1.估计往返时间**

- SampleRTT:某报文段被发出到该报文段被确认接收的时间。TCP仅为已发送但目前尚未确认的报文段估计SampleRTT，但是不对已经被重传的报文段计算SampleRTT.

- EstimatedRTT:估计RTT，TCP维持的一个SampleRTT的均值。一旦获取一个新的SampleRTT,则
  $$
  EstimatedRTT=(1-\alpha)*EstimatedRTT+\alpha*SampleRTT
  $$
  $\alpha$的参考值一般为0.125.，这种加权被称为**指数加权移动平均**。

- RTT变差DevRTT：
  $$
  DevRTT=(1-\beta)*DevRTT+\beta*|SampleRTT-EstimatedRTT|
  $$
  $\beta$推荐值为0.25



2**.设置和管理重传超时间隔**

经验时间：
$$
TimeoutInterval=EstimatedRTT+4*DevRTT
$$

#### 3.5.4 可靠数据传输

**快速重传：**超时重传往往增加了时延，因此引入了快速重传机制。如果TCP发送方接收到相同数据的三个**冗余ACK(不算最开始的那个)**，说明这个数据包已经丢失，TCP就执行**快速重传。**

TCP发送方仅需要维护已发送但未被确认的最小序号和下一个发送的字节的序号看，看起来像是GBN,但有不同。

GBN会重传所有已发送但未被确认的数据包，但是若果对于TCP,发送方发送了1，2,3...N,并且n<N确认包丢失。那么GBN会重传n,n+1,.....N，而TCP最多重传n.

对TCP修改意见可以采用**选择确认**，不采用累计，这样的TCP更像是更像是GBN和SR的混合体。



#### 3.5.5 流量控制

TCP为他的应用程序提供了**流量控制服务**，以消除发送方使接收方缓存溢出的可能性。

与TCP拥塞控制的区别：

拥塞控制的参与方为**发送方和路由器间**，作用于**网络，**(可能会丢包)。而流量控制的参与者为**发送方和接收方**，作用于接收方(不会丢包)



TCP的链接方各自都会维护一个接收窗口，用于给发送方一个指示，该接收方还有多少可用的缓存空间。

<img src="images/42.jpg" style="zoom:35%;" />



对于发送方主机A,

<img src="images/43.jpg" style="zoom:80%;" />

通过以上机制可以得到，流量控制中不会发生丢包现象。

为了避免死锁，TCP规定，当rwnd=0，发送方继续发送一个只有一个字节数据的报文段，这些报文段将会被确认，发送方就知道接收方有新的空闲空间可以用。

#### 3.5.6 TCP连接管理

TCP连接三次握手(three-way handshake)：

1. 客户端SYN标志=1，称为**SYN报文段。**随机选择一个初始序号client_isn
2. TCP接收到SYN会为TCP连接分配缓存和变量，SYN字段为1，确认号字段为client_isn+1，并随即选择自己的初始序号server_isn。该报文段称为**SYNACK报文段**。前两个报文都不携带数据。
3. SYNACK收到之后，客户也要分配缓存和变量，此时连接已经建立了，所以SYN=0,序号为client_isn+1,并且可以携带数据。

三次握手后，客户可以发送数据。

**为什么三次握手？**

- 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，即为了解决“网络中存在延迟的重复分组”的问题

<img src="images/44.jpg" style="zoom:50%;" />





连接关闭：FIN报文段中，FIN字段被设置为1,。

<img src="images/45.jpg" style="zoom:50%;" />



### 3.7 TCP拥塞控制(重点)

TCP发送太快：导致网络拥塞；发送太慢，不能充分利用带宽。·

TCP必须使用端到端拥塞控制而不是使用网络辅助的拥塞控制。TCP让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的数率。

由上节可知TCP每一端都有缓存以及变量。TCP发送方额外维护一个称为**拥塞窗口**的变量**cwnd**,用来对TCP向网络发送的流量速率进行限制。

既发送方未被确认的数据量不能超过cwnd和rwnd的最小值。即
$$
LastByteSent-LastByteAcked\le \min\{cwnd,rwnd\}
$$
为了与流量控制形成对比，我们假设接收缓存足够大(即可以忽略流量控制)，发送数据未被确认的仅和cwnd有关。

TCP发送方**判断丢包**：要么出现超时，要么收到三个冗余ACK.因次发送方可以根据判断丢包情况判断网络拥塞情况，从而控制发送速率。





拥塞控制三个阶段：

- **慢启动(slow start)**：cwnd初始值为一个MSS,每收到一个ACK就增加一个MSS,因此会呈现指数增长，即1-2-4-8-·6...(以MSS为单位)。

  TCP规定，如果出现丢包(即拥塞)，cwnd将重新设置为1。此外还引入了另一个变量**慢启动阈值(sstresh)**，如果出现拥塞，则令**sstresh=cwnd/2。**当cwnd>=sstresh时，结束慢启动进入了拥塞避免模式。

- **拥塞避免**：进入这个状态后，cwnd对于**每个RTT只增加一个MSS**而不是每个ACK都增加，一种通用的方法时每个ACK确认，cwnd增加MSS/cwnd个字节.对于超时事件，cwnd被设置为1个MSS,sstresh被设置为cwnd的一般。但是由三个冗余ACK引起的丢包，拥塞避免阶段只会将cwnd的值减半。并且sstresh的值变成cwnd的一半(cwnd变化前).接下来进入快速恢复阶段。

- **快速恢复：**对于TCP Tahoe(比较老)版本，不管是发生超时丢包还是三次冗余丢包，都无条件将拥塞窗口减为1，进入慢启动。而对于TCP reno，则综合了快速恢复，即出现超时则直接进入慢启动，和TCP Tahoe类似；而收到三次冗余ACK,TCP降低cwnd进入拥塞避免

**两种类型TCP：**



  <img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20230209102208648.png" alt="image-20230209102208648" style="zoom: 50%;" align="center"/>

TCP拥塞控制通常被称为**加性增、乘性减(AIMD）						。**

## 第四章 网络层

### 4.3 网际协议



### 4.5 路由选择算法

**默认路由器**，又叫主机的**第一条路由器**，是与主机连接的第一台路由器。我们将源主机的默认路由器称作**源路由器**，把目的主机的默认路由器称作**目的路由器**。

- **全局式路由选择算法**：用完整的，全局性的网络知识计算出从源到目的地之间的最短路径，即需要知道所有节点之间的连通性以及所有链路的费用。具有全局状态信息的算法称为**链路状态(LS)**算法。
- **分散式路由选择算法**：以迭代，异步和分布式的方式计算出最低费用路径。每个节点仅拥有与其直接 相邻链路的费用。典型算法：DV(距离向量算法)

另一种分类：

- **静态式路由选择算法**：随着时间流逝，路由变化非常缓慢，通常需要人工进行干预。
- **动态式路由选择算法**：当网络流量负载或拓扑发生变化时改变路由选择路径。

第三种分类：

- **负载敏感算法**:链路费用会动态的反应出底层链路的拥塞水平
- **负载迟钝算法**

#### 4.5.1 链路状态(LS)路由选择算法

**Dijkstra算法：**

几个概念：

- **D(v)**：本次迭代，从源节点到节点v的最短路径
- **p(v)**:从源到v的沿着当前最低费用路径的前一节点(前驱，v的邻居)。
- $N^{'}$:当前已经求出最短路径的节点集合

一个例子：

<img src="images/1.png" style="zoom: 50%;" />



<img src="images/2.png" style="zoom: 50%;" />



算法结束后，可以得u中的转发表：

<img src="images/3.jpg" style="zoom:67%;" />



#### 4.5.2 距离向量(DV)路由选择算法

$bellman-ford$方程：

$设d_x(y)是结点x到结点y的最短路径，v是x的邻居$
$$
d_x(y)=min_v\{c(x,v)+d_v(y)\}
$$
$bellman-ford$方程的解为结点**x的转发表提供了表项**

基本思想：

每个结点$x$以$D_x(y)$开始，对在$N$中所有的结点，**估计**自己到结点$y$的最短路径。令$D_x=[D_x(y):y\in N]$为结点$x$的距离向量表示$x$到$N$中其他所有结点的当前最短距离。使用$DV$算法结点，每个$x$维护下列路由选择信息

- 对于每个邻居$v$,从$x$到$v$的费用为$c(u,v)$
- 结点$x$的距离向量，即$D_x=[D_x(y)：y\in N]$,包含了$x$到所有点$y$费用的估计值
- 它的每个邻居$v$的距离向量

每个结点不时地向邻居发送自己的距离向量副本，当结点x的邻居向他发送距离向量时，它保存$v$的距离向量，然后使用$bellman-ford$方程更新自己的距离向量：
$$
D_x(y)=min_v\{c(x,v)+D_v(y)\}
$$
如果结点$x$的距离向量发生改变，将向邻居发送自己的新的距离向量。所有结点以这种异步方式交换距离向量，每个节点的$D_x(y)$将会收敛到$d_x(y)$                                                                                                                                                                     

当收敛后，每个结点向y转发的下一跳路由器即$v^*(y)$，即在$bellman_ford$方程中取得最值的邻居$v$,如果有多个则会选择任意一个。

**链路费用改变导致的无穷计数问题以及毒性逆转：**

<img src="images/4.png" style="zoom: 33%;" />





**LS算法和DV算法比较**

- **报文复杂性**：LS必须直到每条链路的费用，因此需要发送$O(|V||E|)$个报文，且无论何时一条链路发生改变时，必须向所有结点发送新的链路费用。DV要求每次迭代发送相邻结点的链路费用。DV算法当且仅当在新的链路费用更优时才传播已经改变的链路费用。
- **收敛速度**：LS收敛速度为$O(|V|^2)$,而DV算法收敛较慢，且收敛是会遇到路由选择环路。DV算法还会导致无穷计数问题
- **健壮性**：LS算法具有较强的健壮性，而DV算法中，一个结点可以向任意或所有目的结点通告其不正确的最低费用路径。



#### 4.5.3 层次路由选择

**自治系统（AS)**：每个AS由一组通常处相同管理控制下的路由器组成(例如，由相同的ISP运营或属于相同的公司网络)，每个AS又包括不同的子网。

在相同的AS中的所有路由器都全部运行同样的路由选择算法，且拥有彼此的信息。在一个AS内运行的路由选择算法叫做**自治系统内部路由选择协议**。当然，将AS彼此互相关联是必需的，因此在一个AS内的一台或多台路由器将有另外的任务，即负责向在本AS之外的目的地转发分组。这些路由器被称为**网关路由器(gateway router)**。

如果在一个AS中仅有一台网关路由器连接其他AS，则该AS中的一台路由器若想向外部AS发送分组，只需要根据自治系统内部路由选择协议将分组送给内部的网关路由器，再由网关路由器向其所直连的路由器转发。

若AS有多个网关路由器通向外部，处理这种情况，该AS需要：

- 知道经过该AS各个网关路由器所连接的AS可以到达哪些目的地
- 向该AS中的所有路由器传播这些可达性信息，因此每台路由器能够配置它的转发表以处理外部AS目的地。

从相邻AS获取可达性信息和向该AS内部传达可达性信息由**自治系统间路由选择协议**处理。因特网中所有的AS都运行相同的AS间路由选择协议，称为**BGP4。**

在实践中经常使用经常使用的一种方案是**热土豆路由选择**，在这种方案下，AS尽可能尽快地(尽可能经济的)扔掉分组(热土豆)，即按照自治系统内部选择协议选择费用最小的网关路由器(前提是可达目的地)，发送分组到这个网关路由器。选择之后，该路由器将会增加该子网的转发表表项

### 4.6 因特网中的路由选择

####  4.6.1 因特网中自治系统内部的路由选择：RIP

AS内部路由选择又被称为**内部网关协议**。比较出名的是**路由选择信息协议(Routing Information Protocol)**和**开放最短路优先协议(Open Shortest Path First)**。

RIP是一种**距离向量协议**，

####  4.6.2 因特网中自治系统内部的路由选择：OSPF

####  4.6.3 自治系统间的路由选择：BGP



### 4.7 广播和多播路由选择(大概了解)

#### 4.7.1 广播路由选择算法

#### 4.7.2 多播





## 第五章 链路层：链路、接入网和局域网



### 5.1 链路层概述

**结点**：运行链路层协议的任何设备称为结点，结点包括主机、路由器、交换机和WiFi接入点等等。

**链路**：沿着通信路径连接相邻结点的通信信道称为链路。

在通过特定的链路时，传输结点将数据封装在**链路层帧**中。

#### 5.1.1 链路层提供的服务

- **成帧(framing)**
- **链路接入**：**媒体访问控(MAC)**制协议规定了帧在链路上传输的规则。
- **可靠交付**
- **差错检测和纠正**

#### 5.1.2 链路层在何处实现

链路层主体在**网络适配器(network adapter)**实现，网络适配器有时又被称为**网络接口卡(Network Interface Card)**，位于网络适配器核心的是**链路层控制器**，是一个实现了许多链路服务的专用芯片。因此，链路层服务大多是硬件实现的

### 5.2 差错检测和纠正技术

使用**差错检测和纠正比特（EDC)**来增强数据D,接收方需要接收到$D'和EDC'$,确定D和D’是否相同，若不同，则称检测到了一个差错。(不是出现差错)

未检测出差错都可能存在，需要选择合适检测错误方案，使得这种错误出现概率尽可能小。

三种差错检测方法：

- **奇偶校验**
- **检验和方法**
- **循环冗余检测(Cyclic Redundancy Check)**

#### 5.2.1 奇偶校验

增加奇偶校验位，保证1的个数为奇/偶，但当同时有两个以上比特发生差错，无法检测，于是引入了二维奇偶校验

<img src="images/8.jpg" style="zoom: 25%;" />

#### 5.2.2 校验和

检验和中，将d比特数据看成一个k比特整数序列。然后将这些序列处理，一个简单方法就是将这些序列加起来。**因特网检验和**就是这样，将数据字节作为16比特序列求和，然后将反码形成了报文中的因特网检验和。接收方只需要通过接收的数据(包括检验和)的和取反码，看看是否为全1 比特。有0就说明出现了差错。TCP和UDP对首部和数据字段都要计算检验和，而IP数据报只需要计算首部校验和。

#### 5.2.3 循环冗余检测(CRC)

**循环冗余检测编码**又被称为**多项式编码**。

**生成多项式**：如1011：表示为$x^3+x+1$

**模2运算：**在这种运算下，加法不进位，减法不借位。

发送和接收方需要约定一个$r+1$比特的**生成多项式**，对于d比特的数据，在后面添加一个r比特的数据$R$,使得
$$
D*2^r\oplus R=nG\Leftrightarrow D*2^r=nG\oplus R
$$
因此我们可以在模2运算下计算$D*2^r除以G$的余数即为R。

<img src="D:\Markdown\md\期末复习\images\9.jpg" style="zoom:20%;" />

算完之后可以代回去检测一下是否成立。



### 5.3 多路访问链路和协议(重点)



### 5.4 交换局域网

#### 5.4.1 链路层寻址和ARP(掌握)



#### 5.4.2 以太网

#### 5.4.3 链路层交换机(掌握)

